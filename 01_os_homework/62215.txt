Източници:
http://macappstore.org/tre/
https://formulae.brew.sh/formula/tre

Тъй като съм на MacOS:
* Инсталирам agrep чрез 'brew install tre' (горе в ресурсите)
и му използвам
-w -> да съвпадат само цели думи
-B -> най-добрите съвпадения
-s -> да изпринти левенщайн разстоянието с думата 

- Чрез tr -cs '[:alpha:]' '\n' < text.txt взимам всяка една дума от файла
на нов ред като изключваме пунктуацията

- След това с awk и функцията tolower правя всички думи да с малки букви

- Сортирам думите, за да мога да махна след това с uniq повтарящите се

- Сега чрез xargs искам да подам на agrep като аргумент всяка една от думите
от файла text.txt, като agrep с тези аргументи ще върне левенщайн
разстоянието залепено с две точки до думите с най-малко разстояние от
dic.txt, но също така искам и да изкарам и думата, която съм подал като
аргумент.

- Затова ползвам sh, за да мога да извърша двете команди едновременно
и между тях слагам две точки, за да мога после да ги манипулирам.

- Има проблем обаче, че командите echo и agrep се изпълняват на различни
редове. Затова с tr заменям редовете с две точки и накрая слагам нов ред,
защото иначе всичко се слага на един ред.
=> Така се получава следната конвенция:
holy::3:he:3:now:3:say:3:of:3:should:3:to:
-> първата дума е аргумента, с който сравняваме
и след :: е левенщайн разстоянието до дадените думи

- Така се получават обаче излишни нови редове. Затова с grep . взимам редовете,
които не са празни и си решавам проблема.

- Накрая с awk и вече готовите приготовления взимам първия, третия и четвъртия
фийлд на реда, на които левенщайн разстоянието не е нула (там където думата
не съвпада), защото ако разстоянието е нула, то има такава дума в dic.txt
=> по условие не трябва да ги изписваме. Взимаме точно третия и четвъртия,
защото третия е разстоянието, а четвъртия е първата дума, която е съвпаднала,
а по условие точно това търсим.

