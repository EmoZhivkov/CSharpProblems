# First
(НЯМАТЕ ПРАВО ДА ИЗПОЛЗВАТЕ ГОТОВИ БИБЛИОТЕКИ И ИМПЛЕМЕНТАЦИИ НА СВЪРЗАН СПИСЪК)

Създайте свързани списък, който чете поток от числа от входа ( четете докато ви се подават числа на входа ).

След това обходете линейно вашият списък и изведете като резултат: минималното,максималното и сумата от числата в списъка.

# Second

Получавате като вход число N.

Следват N числа които трябва да ги прочетете и съхраните в собственоръчно написан Свързан Списък.

Следва число P. Следват P числа на нов ред. ( тях може да съхраните по начин който е най-удобен за вас ).

От вас се изисква да върнете броя на различните двойки елементи ( (1,2) и (2,1) е една и съща двойка ) които се срещат в масива P и са съседи във вашият свръзан списък.

Input Format

Число N ( размер на вашият свързан списък )

Следват N числа.

Число P.

Следват P числа. ( Важно !!! Тези P числа можете да използвате каквото искате нагото може в масив, може в свързан списък, абс както си решите ги пазете )

Constraints

N <= 1 000 000

Всеки един елемент е между 1 и 1234 ( включително ).

P <= 3000 ( дължината на P )

Всяко едно число в масива P между 1 и 1 000 000 000.

Output Format

Число X: броят на двойките които удовлетворяват условието.

Пример:

Пример:

4

1 2 3 4

5

6 1 2 3 4

Изход:

3

Пояснение:

1->2->3->4 ( 1->2, 2->3, 3->4 като числата 1,2,3,4 се срещат в P )

# Third

Зимата идва и студентите от Снежно Инженерство ( СИ ) решили всички заедно послучай Контролно Номер 2 да си направят снежен човек. Студентите от СИ са създали специално клониращо устройство което клонира избран от тях снежен човек ( тъй като мързела е източник на идеи ).

В началото те имат 0-лев снежен човек с 0 топки на него !!!

Input Format

На вход получавате N заявки:

p m - клониране на p-ия снежен човек ( 0 <= p < i ), където това е i-тата заявка. След клониране добавяте топка с маса m върху новият клонинг. ГАРАНТИРАНО Е ЧЕ ЩЕ КЛОНИРАТЕ САМО СЪЩЕСТВУВАЩИ ТОПКИ.

p 0 - клониране на p-ия снежен човек и премахване на най-горната топка на новият клонинг. ГАРАНТИРАНО Е ЧЕ НЯМА КЛОНИРАТЕ И ДА ПРЕМАХВАТЕ ТОПКА ОТ НУЛЕВ СНЕЖЕН ЧОВЕК. ГАНРАНТИРАН

След N-те заявки, изведете сумата на всичките създадени снежни човеци.

Constraints

1 <= N <= 1 000 000 масата m, на всяка нова топка която трябва да се добави 1 <= m <= 1000

Output Format

След N-те заявки, изведете сумата на всичките създадени снежни човеци.

Пример:

8

0 1

1 5

2 4

3 2

4 3

5 0

6 6

1 0

Изход:

74

Пояснение на примера:

Заявките започват с номерация 1 ! ПРИ N = 8 номерацията на заявките ще започне от 1 до ... 8. i-я снежен човек се получава след i-тата заявка !

В началото имате снежен човек с 0 топки който е създаден при заявка i = 0 по подразбиране

0 1, това е заявка номер 1, след нея е създаден снежен човек за i = 1, който клонира снежен човек i = 0 и му добавя топка с тежест 1 => 0 + 1 => [1]

1 5, това е заявка номер 2, след нея е създаден снежен човек за i = 2, който клонира снежен човек i = 1 и му добавя топка с тежест 5 => 1 + 5 => [6]

2 4, това e заявка номер 3, след нея е създаден снежен човек за i = 3, който клонира снежен човек i = 2 и му добавя топка с тежест 4 => 6 + 4 => [10]

3 2, това е заявка номер 4, след нея е създаден снежен човек за i = 4, който клонира снежен човек i = 3 и му добавя топка с тежест 2 => 10 + 2 => [12]

4 3, това е заявка номер 5, след нея е създаден снежен човек за i = 5, който клонира снежен човек i = 4 и му добавя топка с тежест 3 => 12 + 3 => [15]

5 0, това е заявка номер 6, след нея е създаден снежен човек за i = 6, който клонира снежен човек i = 5 и премахва най-горната му топка => 15 - 3 => [12]

6 6, това е заявка номер 7, след нея е създаден снежен човек за i = 7, който клонира снежен човек за i = 6 и добавя топка с тежест 6 => 12 + 6 => [18]

Общата сума на всички снежни човеци е: 1 + 6 + 10 + 12 + 15 + 12 + 18 => 74

# Fourth

Митьо Пищова обича да прави пищове по време на контролните на Милен Ч++ в зала 210 на Химическия Факултет.

Обаче Пищова не е сам, колегите му стоящи отдясно по време на контролното постоянно го снабдяват с нови и нови пищови на тема Merge,Binary Search и Counting Sort.

Милен Ч++ като един внимаващ квестор забелязва листчетата но вместо да ги крие и да прави забележка на Митьо, той ги разбърква за да може дори и когато Митьо преписва да се потруди пренареждайки отново QuickSort пищовите си.

Input Format

На стандартния вход получавате N заявки:

Всяка заявка е от вида:

add x - ( където x е номер на пищов )) например add 1

gun - означава че Митьо ще започне да преписва

milen - означава че Милен Ч++ идва, вижда го и му пренарежда пищовите.

В началото не разполагате с никакви средства за преписване.

При заяка add x, вие получавате тема и я слагате най-отдясно на вече текущо наредените теми под вашият чин.

Например: 2

add 3

add 1

=> Като краен резултат под чина ще получите 3 1

3

add 1

add 3

add 2

=> Като краен резултат под чина ще получите 1 3 2

при команда gun, вие преписвате от най-десния елемент на вашата редица от пищови, ВАЖНО НЯМА ДА ПОЛУЧИТЕ КОМАНДА gun при 0 брой пищови. След команда gun, премахвате и слагате в джоба си най-дясното листче.

Пример

4

add 3

add 2

add 4

gun

=> Крайната наредба става: 3 2 ( 4 се преписва успешно от Митьо )

Команда milen, Когато Милен Ч++ дойде, той хваща първата половина ( ПРИ НЕЧЕТЕН БРОЙ ВЗЕМА С 1 ЕЛЕМЕНТ ПО-МАЛКО ОТ ЛЯВАТА ПОЛОВИНА ПРИ 5 елемента взема 2 от ляво ) от вашата редица от числа и я премества елементите един по един най-отдясно.

Пример

5

add 1

add 2

add 3

add 4

milen

Крайна наредба: 3 4 1 2 ( Първоначално имате 1 2 3 4, Милен Ч++ идва и хваща 1 и 2 и ги слага един по един отдясно на 3 и 4 )

Constraints

Ограничения:

Брой на заявките N, където N <= 1 000 000

Всяка заявка е от вида:

add x

gun

milen

НЯМА ДА ПОЛУЧИТЕ gun при ПРАЗНА РЕДИЦА, НЯМА ДА ПОЛУЧИТЕ milen при ПРАЗНА РЕДИЦА. x в заявката add ще е <= N и няма да получите повтарящи x.

Тоест следният вход е невъзможен:

5

add 1

add 1

add 1

add 1

add 1

Вход:

N заявки от вида: add x, gun, milen

Output Format

Изход:

Броят пищови под чина на Митьо и на нов ред:

Крайната наредба на пищовите на Митьо след N-те заявки.

Пример:

Вход:

8

add 1

add 2

add 4

add 3

add 5

add 8

gun

milen

Изход:

5

4 3 5 1 2

# Fifth

Смърфиета много обича да пише стихове на клавиатурата си.

Нейният зъл братовчед Смърфофан пък обича да прави подли трикове на своята

братовчедка в нашият случай тайно натискайки Home & End бутоните на клавиатурата докато тя пише своя стих.

Символът: "[" означава че е натиснат Home button

Символът: "]" означава че е натиснат End button

На входа получавате числото Q.

Следват Q реда всеки с текст до 10 000 000 символа.

Текста ще бъде въведен от Смърфиета но и с намесата на нейният зъл братовчед, от вас се изисква да отпечатате какво ще бъде изведено на екрана.

Например: Ако текста е: World[Hello]

То смърфието ще тръгне да въвежда текста World, след това нейният зъл братовчед ще премести курсора за текст в началото и така смърфието написвайки Hello ще го залепи пред World, последният символ ] просто е случаен и в нашият случай не влияе.

Ще бъде отпечатано съобщението: HelloWorld

Втори Пример:

[][][]HelloWorld

Тук в началото ше има премествания на курсора върху празен текст и това няма да окаже никакво влияние и Смърфиета ще си отпечата HelloWorld.

Input Format

Q заявки следват Q текста S

Constraints

Q заявки ( Q <= 100 000 )

за всяка заяка текст S с дължина S <= 10 000 000

ВАЖНО: Q * S <= 100 000 000

Output Format

За всяка заяка изведете какъв текст ще се изведе на екрана